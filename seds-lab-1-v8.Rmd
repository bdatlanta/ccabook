---
title: "SEDS Lab 1"
author: "Bill Drummond"
date: "9/14/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE)
```

# SEDS and tidyverse background

The State Energy Data System (SEDS) dataset consists of more than 700 energy-related variables for the U.S., 50 states, and Washington D.C. covering the years 1960 to about two years before the current year. To manipulate this large dataset we will be using the R tidyverse package of packages, and the dplyr and ggplot packages that are part of the tidyverse.

In this lab we will focus on five commands and one operation.  The operation is the **pipe operation**, designated in R code with the **%>%** combination of symbols.  It simply moves the current dataframe from one command to the next command without storing a copy of the dataframe in it's intermediate state.

Tidyverse-compliant commands always accept a dataframe as the assumed first input (technically called an "argument") and produce a dataframe as the command output.  This means that when you write a series of piped commands you only have to specify the input and output once, at the beginning of the command sequence.

The most common format for tidyverse/dplyr data manipulation is:
```
outdf = indf %>% 
        command1() %>% 
        command2() %>% 
        command3()
```
The two common commands to easily read csv files and spreadsheets into dataframes are the read_csv() and read_excel() commands.  (Sidenote: the read_excel() command is actually part of the tidyverse-compliant readxl package, which must be loaded with library() sepratately from the tidyverse.)

The three tidyverse/dplyr commands that we use constantly are select, filter, and mutate.  

1. **Select** creates a subset of the columns in a dataframe.  There are many ways to designate the selected columns.  Two of the most frequent are listing the columns separated by commas: **select(msn, data)** and designating a variable to NOT select with the minus sign: **select(-data_series).**
2. **Filter** creates a subset of the rows in a dataframe.  You specify a logical condition that filter applies to each row.  If the condition is true the row is included.
3. **Mutate** creates a new variable as a result of a mathematical operation or some other manipulation of the existing data in each row.  For **mutate** to do it's job well it needs the input data for the calculation to be available somewhere within the row, except for constant values.


# Setup Lab


Start open seds-lab-1.html in a Web browser.

From the class0721 folder, right-click on seds-lab-1.R and open in RStudio.

The first block of code for loading libraries is already entered.  Highlight those commands and press CTRL+ENTER to execute.

In the HTML file R code is shown in grey blocks.  You can highlight one or more lines of code, press CTRL-C and paste them with CTRL-V into your R file.  Highlight the new lines and press CTRL-ENTER to execute.  Your output should be similar to the output shown in the HTML file.

This code loads libraries and a set of Drummond's custom functions.  If you get an error, you may need to install one or more libraries.
```{r Setup, results="hide",warning=FALSE,message=FALSE}
library(tidyverse)
library(readxl)
library(sf)
library(tmap)
library(RColorBrewer)
library(viridis)

source("./functions/functions1b.R")
```

Before you execute the following setwd command you will need to remove the comment hashtag and change the path to "m:/temp/class0721" or whatever path you need to specify for your location of the class0721 folder.

You may also need to install the viridis package.  Again, copy and paste into the console, remove the hashtag, and execute.

```{r}
# setwd("m:/temp/class0721")
# install.packages("viridis")
```


```{r}

```


# Load Complete SEDS

The data source is from:

https://www.eia.gov/state/seds/seds-data-complete.php?sid=US#CompleteDataFile

We'll read the complete SEDS with read_csv.  Drummond's custom tolow3() function (see code in functions1b.R in the functions folder) converts variable names to valid R lowercase names with underscores replacing any periods or spaces.

The msn1 dataframe reads from a spreadsheet the entire list of variables in the complete SEDS.

Note: the %>% pipe command that passes (pipes) the altered dataset from one tidyverse command to the next, without bothering to save any intermediate version.

Note: the read_excel command can specify the name of a certain sheet and can skip initial rows that don't contain column names or actual data.


```{r Load SEDS}

seds1 = read_csv("./data/Complete_SEDS.csv") %>% 
  tolow3()

msn1 = read_excel("./data/Codes_and_Descriptions.xlsx", sheet="MSN Descriptions", skip=9) %>% 
  tolow3()

```

The columns in the SEDS dataframe are:

* data_status: information on the dataset version/release
* msn: a five letter code for the specific series/variable
* statecode: two letter postal abbrivation for each state
* year: year for which data was collected
* data: actual data value
  
This is a "long" dataframe.  There are so many variables in SEDS it would be exceedingly awkward to place each one in a column.  Instead the msn value tells us what is being measured, and data value is the actual amount.

View the msn1 dataframe. Spend 5 minutes browsing the msn descriptions.

The five-character msn consists of three parts:

* Characters 1-2 are the source fuel
* Characters 3-4 are the end-use sector using the energy
* Character 5 is the units of the data value
  
Here are the common codes used in the msns:


![Five Character MSN Names](./images/msn.png "Five character MSN Names"){ width=75% }


![Two Character MSN Energy Source](./images/msn-energy-source.png "Two Character MSN Energy Source"){ width=100% }

![Two Character MSN End-Use Sector](./images/msn-sector.png "Two Character MSN End-Use Sector"){ width=75% }

![One Character MSN Units](./images/msn-units.png "Two Character MSN Energy Source"){ width=75% }

# Filtering SEDS data 

The SEDS dataset contains more than 1.8 million rows. Assume we want to explore electricity and electricity fossil fuel emissions in particular.  We'll use four msns from SEDS and ignore petroleum, which is very small compared to coal and natural gas:

1. CLEIB: electricity coal BTUs released, in billions
2. NGEIB: electircity natural gas BTUs released, in billions
3. GDPRX: Real gross domestic product in millions of chained (2012) dollars (removes effect of inflation)
4. TPOPP: Resident population including Armed Forces in thousands

We will now filter the full SEDS dataset for only our four msn series and four areas of interest: Georgia, North Carolina, California, and the full US.

Note: c("CLEIB","NGEIB","TPOPP","GDPRX") and c("GA","NC","CA","US")) are vectors of multiple values

Note: the %in% operator tests to see if a value can be found in a vector of values.  If so, the result is TRUE.

pivot_wider() transforms the "long" data (with variable names in a column and data values in a single column) into "wide" data with separate columns for each msn.


```{r Filters for specific rows and makes wide format}
fourareas1 = seds1 %>% 
  select(msn, statecode, year, data) %>% 
  filter(msn %in% c("CLEIB","NGEIB","TPOPP","GDPRX")) %>% 
  filter(statecode %in% c("GA","NC","CA","US")) %>% 
  pivot_wider(names_from=msn, values_from=data) 

```

# Calculating CO2 emissions

We calculate new variables with this process:

1. Convert coal (and natural gas) BTU billions (10^9) to coal (and natural gas) BTU quadrillions (quads, 10^15) by dividing by 10^6.
2. Multiply coal and natural gas quads times CO2 coefficients to calculate millions of metric tons of CO2
3. Adding coal and natural gas for fossil fuel CO2 millions of metric tons (mmt). (Petroleum emissions are very, very small in comparison and can be ignored for these calculations.)
4. Calculate mmt per million population and per trillion GDP dollars

```{r Calculate normalized coal/ng electricity values}
fourareas2 = fourareas1 %>% 
  mutate(CLEIQ = CLEIB / 10^6,
         NGEIQ = NGEIB / 10^6,
         CLMMT = CLEIQ * 95.52,
         NGMMT = NGEIQ * 53.01,
         FFMMT = CLMMT + NGMMT,
         mmtperpopm = FFMMT/TPOPP*10^3,
         mmtpergdpt = FFMMT/GDPRX*10^6)

```

# Visualizing results

We now graph the results to compare the four areas in "normalized" terms of mmt per million persons and mmt per trillion dollars in GDP.

We'll use ggplot to create line plots showing year-to-year changes.  Line plots are very similar to scatterplots, except 

1. The x variable is a time variable such as year
2. geom_line() draws a continuous line, rather than geom_point() drawing points

Note: GDP data is only available from 1997 onward.

Note: ggplot can subset a dataset in a way similar to the dplyr filter command.

```{r}
ggplot(data=fourareas2) +
  geom_line(aes(x=year,y=mmtperpopm,color=statecode))

ggplot(subset(fourareas2,year>=1997)) +
  geom_line(aes(x=year,y=mmtpergdpt,color=statecode))
  
```

# Questions for thought and discussion:

**From the first (population) chart:**

Any guesses regarding the dramatic decline that started in North Carolina in 1980 and Georgia in 1985?

When did the second big Georgia decline start?

Make a common sense test: what is the most recent level of electricity CO2 emissions per person in the US?  Does this make sense, given an overall level of 20 metric tons of emissions per person in the US?

**From the second (gdp) chart:**

What has happened to Georgia emissions per unit of economic output from 1997 to 2018?

What is the overall pattern in emissions per unit of economic output?

**From both charts:**

California! Why is California so much lower?  Is California-level emissions possible for the rest of the US?

# Mapping results

We'd now like to map the amount of coal burned for electricity per capita for the continential US.

The code below 

* reads the state shapefile from the gisdata subfolder,
* converts variable names to lower case,
* calculates statecode, the two character state postal code, and
* filters for only the states in the continental US.

```{r}

st1 = st_read("./gisdata/cb_2018_us_state_20m.shp") %>% 
  tolow3() %>% 
  mutate(statecode = stusps) %>% 
  filter(statecode != "AK" & 
         statecode != "HI" &
         statefp <= "56") 

```

We now construct the attribute dataset from the complete seds by

* filtering for the most recent year
* filtering for the two data series: coal burned for electricity (in billions of BTU) and population (in thousands)
* selecting only the variables we need
* pivoting wider so CLEIB and TPOPP become separate columns
* calculating the coalpercap variable (billion BTU / thousand population).

```{r}

sedsmapdata = seds1 %>% 
  filter(year == 2019) %>% 
  filter(msn %in% c("CLEIB","TPOPP")) %>% 
  select(statecode, year, msn, data) %>% 
  pivot_wider(names_from=msn,values_from=data) %>% 
  mutate(coalpercap = CLEIB/TPOPP)
```


We Now join the attributes to the spatial data with the statecode variable, and make statecode the first variable so mouse hovering in tmap will show its value.

```{r}

st2 = st1 %>% 
  left_join(sedsmapdata) %>% 
  select(statecode,everything())


```

We produce an interactive quantile map with 70% opacity, or 30% transparency using the plasma palette from the viridis library.

Note: a "-" in front of a palette name reverses the colors.

```{r}

tmap_mode("view")

tm_shape(st2) +
  tm_polygons("coalpercap",
              style="quantile",
              palette="-plasma",
              alpha=.70)
```

Note: we are using the striking plasma palette from the viridis library.  Here are the palettes in viridis:

![Viridis library palettes](./images/viridis.png){ width=75% }

----------------------

For reference, here are the more sedate palettes from RColorBrewer:

![RColorBrewer library palettes](./images/rcolorbrewer.png){ width=75% }


